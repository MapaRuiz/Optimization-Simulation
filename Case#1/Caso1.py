# -*- coding: utf-8 -*-
"""Ford-Fulkerson

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TMvrOPNzRRVwqqSZb8P7NO63yKDfVfOL
"""

import copy
import random
import collections
import heapq

# -----------------------------
# Función Auxiliar: Inicializar la Red Residual
# -----------------------------
def inicializar_red_residual(grafo):
    """
    Crea la red residual a partir del grafo original.
    Para cada arco (u -> v) con capacidad c, se añade un arco inverso (v -> u)
    con capacidad 0 (si no existe).
    """
    residual = {}
    for u in grafo:
        residual[u] = {}
        for v, cap in grafo[u].items():
            residual[u][v] = cap
    for u in grafo:
        for v in grafo[u]:
            if v not in residual:
                residual[v] = {}
            if u not in residual[v]:
                residual[v][u] = 0
    return residual

# -----------------------------
# Funciones de Estrategia para el Ordenamiento en DFS
# -----------------------------
def estrategia_menor(current, residual):
    """Devuelve los vecinos ordenados de forma ascendente según la capacidad disponible."""
    vecinos = [n for n in residual[current] if residual[current][n] > 0]
    return sorted(vecinos, key=lambda n: residual[current][n])

def estrategia_mayor(current, residual):
    """Devuelve los vecinos ordenados de forma descendente según la capacidad disponible."""
    vecinos = [n for n in residual[current] if residual[current][n] > 0]
    return sorted(vecinos, key=lambda n: residual[current][n], reverse=True)

def estrategia_aleatoria(current, residual):
    """Devuelve los vecinos en un orden aleatorio."""
    vecinos = [n for n in residual[current] if residual[current][n] > 0]
    random.shuffle(vecinos)
    return vecinos

# -----------------------------
# Buscador de Caminos Aumentantes con DFS
# -----------------------------
def dfs_encontrar_camino(residual, fuente, sumidero, funcion_ordenamiento):
    """
    Encuentra un camino aumentante usando DFS.
    La función 'funcion_ordenamiento' determina el orden en el que se exploran los vecinos.
    """
    pila = [(fuente, [fuente])]
    while pila:
        u, camino = pila.pop()
        if u == sumidero:
            return camino
        for v in funcion_ordenamiento(u, residual):
            if v not in camino and residual[u][v] > 0:
                pila.append((v, camino + [v]))
    return None

# -----------------------------
# Buscador de Caminos Aumentantes con BFS Ordenado
# -----------------------------
def bfs_ordenado(residual, fuente, sumidero, orden="min"):
    """
    Encuentra un camino aumentante usando BFS, ordenando los vecinos según la capacidad.
    El parámetro 'orden' puede ser "min", "max" o "aleatorio".
    """
    cola = collections.deque([(fuente, [fuente])])
    visitados = set([fuente])
    while cola:
        u, camino = cola.popleft()
        if u == sumidero:
            return camino
        # Se recopilan los vecinos con capacidad disponible que no estén en el camino
        vecinos = [(v, residual[u][v]) for v in residual[u] if residual[u][v] > 0 and v not in camino]
        if orden == "min":
            vecinos.sort(key=lambda x: x[1])
        elif orden == "max":
            vecinos.sort(key=lambda x: x[1], reverse=True)
        elif orden == "aleatorio":
            random.shuffle(vecinos)
        for v, _ in vecinos:
            if v not in visitados:
                visitados.add(v)
                cola.append((v, camino + [v]))
    return None

# -----------------------------
# Estrategia Heurística Best-First Search (Estrategia B)
# -----------------------------
def best_first_heuristica_B(residual, fuente, sumidero, alpha=1, beta=1):
    """
    Estrategia heurística Best-First Search.
    Puntaje = alpha * (capacidad del cuello de botella) - beta * (longitud del camino - 1)
    Se utiliza una cola de prioridad (simulada con negativos) para elegir el camino con mayor puntaje.
    """
    cola_prioridad = []
    cuello_inicial = float('inf')
    puntaje_inicial = - (alpha * cuello_inicial - beta * (1 - 1))
    heapq.heappush(cola_prioridad, (puntaje_inicial, [fuente], cuello_inicial))

    while cola_prioridad:
        puntaje, camino, cuello = heapq.heappop(cola_prioridad)
        if camino[-1] == sumidero:
            return camino
        actual = camino[-1]
        for v in residual[actual]:
            if residual[actual][v] > 0 and v not in camino:
                nuevo_cuello = min(cuello, residual[actual][v])
                nuevo_camino = camino + [v]
                nuevo_puntaje = - (alpha * nuevo_cuello - beta * (len(nuevo_camino) - 1))
                heapq.heappush(cola_prioridad, (nuevo_puntaje, nuevo_camino, nuevo_cuello))
    return None

# -----------------------------
# Implementación del Algoritmo Ford-Fulkerson
# -----------------------------
def ford_fulkerson(grafo_original, fuente, sumidero, encontrar_camino):
    """
    Ejecuta el algoritmo Ford-Fulkerson usando la función 'encontrar_camino' proporcionada.
    Retorna el flujo máximo, la cantidad de iteraciones (rutas) y un log detallado de cada ruta.
    """
    residual = inicializar_red_residual(grafo_original)
    flujo_max = 0
    contador_rutas = 0
    log = []

    while True:
        camino = encontrar_camino(residual)
        if not camino:
            break
        flujo = min(residual[camino[i]][camino[i+1]] for i in range(len(camino)-1))
        for i in range(len(camino)-1):
            u, v = camino[i], camino[i+1]
            residual[u][v] -= flujo
            residual[v][u] += flujo
        flujo_max += flujo
        contador_rutas += 1
        entrada_log = {
            "ruta": contador_rutas,
            "camino": camino,
            "flujo_enviado": flujo,
            "flujo_max_acumulado": flujo_max,
            "red_residual": copy.deepcopy(residual)
        }
        log.append(entrada_log)
    return flujo_max, contador_rutas, log

# -----------------------------
# Función para Imprimir el Log
# -----------------------------
def imprimir_log(log):
    for entrada in log:
        print("Ruta:", entrada["ruta"])
        print("Camino:", entrada["camino"])
        print("Flujo enviado:", entrada["flujo_enviado"])
        print("Flujo máximo acumulado:", entrada["flujo_max_acumulado"])
        print("Red residual:")
        for u in sorted(entrada["red_residual"]):
            print(f"  {u}: {entrada['red_residual'][u]}")
        print("-" * 40)

# -----------------------------
# Función Principal: Definir el Grafo y Ejecutar las Estrategias
# -----------------------------
def main():
    # Definir el grafo según el ejercicio
    grafo = {
        1: {2: 35, 3: 14, 4: 25, 5: 16, 8: 21},
        2: {5: 20, 6: 36, 8: 26},
        3: {5: 18, 6: 27, 7: 24},
        4: {6: 11, 7: 39, 8: 25},
        5: {9: 38, 11: 18},
        6: {9: 23, 10: 11},
        7: {10: 20, 11: 21, 12: 20},
        8: {11: 28, 12: 38},
        9: {10: 23, 13: 22},
        10: {11: 37, 13: 37, 14: 11},
        11: {14: 14, 15: 14},
        12: {13: 13, 15: 15},
        13: {14: 37, 15: 18},
        14: {15: 11},
        15: {}
    }
    fuente = 1
    sumidero = 15

    # Definir 7 estrategias:
    estrategias = {
        "DFS: Menor Capacidad": lambda residual: dfs_encontrar_camino(residual, fuente, sumidero, estrategia_menor),
        "DFS: Mayor Capacidad": lambda residual: dfs_encontrar_camino(residual, fuente, sumidero, estrategia_mayor),
        "DFS: Aleatorio": lambda residual: dfs_encontrar_camino(residual, fuente, sumidero, estrategia_aleatoria),
        "BFS: Ordenado (Menor Capacidad)": lambda residual: bfs_ordenado(residual, fuente, sumidero, orden="min"),
        "BFS: Ordenado (Mayor Capacidad)": lambda residual: bfs_ordenado(residual, fuente, sumidero, orden="max"),
        "BFS: Ordenado (Aleatorio)": lambda residual: bfs_ordenado(residual, fuente, sumidero, orden="aleatorio"),
        "Heuristic Best-First Search B": lambda residual: best_first_heuristica_B(residual, fuente, sumidero, alpha=1, beta=1)
    }

    resultados = {}
    # Ejecutar Ford-Fulkerson para cada estrategia e imprimir el log
    for nombre, encontrar_camino in estrategias.items():
        print(f"\nEjecutando estrategia: {nombre}\n" + "=" * 50)
        flujo_max, rutas, log = ford_fulkerson(grafo, fuente, sumidero, encontrar_camino)
        imprimir_log(log)
        print(f"Flujo Total: {flujo_max}, Número de Rutas: {rutas}")
        print("=" * 50)
        resultados[nombre] = (flujo_max, rutas)

    # Imprimir tabla resumen comparativa
    print("\nTabla Resumen:")
    print("{:<40} {:<15} {:<15}".format("Estrategia", "Flujo Total", "Número de Rutas"))
    for nombre, (flujo, num_rutas) in resultados.items():
        print("{:<40} {:<15} {:<15}".format(nombre, flujo, num_rutas))

if __name__ == "__main__":
    main()

import matplotlib.pyplot as plt
import numpy as np

def diccionario_a_matriz(adj_dict):
    """
    Dado un diccionario de diccionarios (adj_dict),
    construye una matriz (lista de listas) con los valores.
    - Si no existe la conexión o es 0, se deja vacío ("").
    - Se determina el tamaño n por el nodo máximo.
    Retorna una lista de listas (strings).
    """
    # 1) Determinar el nodo máximo
    max_nodo = max(adj_dict.keys())
    for subdic in adj_dict.values():
        if subdic:  # si no está vacío
            max_nodo = max(max_nodo, max(subdic.keys()))

    # 2) Crear la matriz llena de cadenas vacías
    n = max_nodo
    matriz = [["" for _ in range(n)] for _ in range(n)]

    # 3) Rellenar la matriz con los valores
    for i, subdic in adj_dict.items():
        for j, valor in subdic.items():
            if valor != 0:  # si quieres mostrar el 0, cambia la condición
                matriz[i-1][j-1] = str(valor)

    return matriz

def dibujar_cuadricula(matriz):
    """
    Dibuja la matriz como una cuadrícula, con bordes en cada celda
    y etiquetas de fila y columna (1..n).
    """
    n = len(matriz)

    fig, ax = plt.subplots(figsize=(n, n))

    # Mostramos un "mapa de calor" de fondo, aunque sea blanco,
    # para poder superponer la cuadrícula y los textos.
    # (Aquí usamos un array numérico con ceros para que sea "blanco")
    data_numerica = np.zeros((n, n))
    cax = ax.imshow(data_numerica, cmap='Greys', vmin=0, vmax=1)

    # Dibujar líneas de cuadrícula
    ax.set_xticks(np.arange(-0.5, n, 1), minor=True)
    ax.set_yticks(np.arange(-0.5, n, 1), minor=True)
    ax.grid(which='minor', color='black', linestyle='-', linewidth=1)

    # Quitar los ticks principales
    ax.set_xticks([])
    ax.set_yticks([])

    # Etiquetas de filas y columnas: 1..n
    # (movemos un poco las etiquetas para que queden centradas)
    ax.set_xticks(np.arange(n), minor=False)
    ax.set_yticks(np.arange(n), minor=False)
    ax.set_xticklabels(range(1, n+1))
    ax.set_yticklabels(range(1, n+1))

    # Colocar texto en cada celda
    for i in range(n):
        for j in range(n):
            valor = matriz[i][j]
            if valor != "":
                ax.text(j, i, valor, ha='center', va='center', color='black', fontsize=12)

    plt.show()

# ======================
# EJEMPLO DE USO
# ======================
if __name__ == "__main__":
    # Diccionario de ejemplo
    adj_dict_1 = {
  1: {2: 6, 3: 14, 4: 25, 5: 2, 8: 6}
  ,2: {5: 2, 6: 25, 8: 26, 1: 29}
  ,3: {5: 18, 6: 27, 7: 24, 1: 0}
  ,4: {6: 11, 7: 39, 8: 25, 1: 0}
  ,5: {9: 20, 11: 4, 1: 14, 2: 18, 3: 0}
  ,6: {9: 23, 10: 0, 2: 11, 3: 0, 4: 0}
  ,7: {10: 20, 11: 21, 12: 20, 3: 0, 4: 0}
  ,8: {11: 28, 12: 23, 1: 15, 2: 0, 4: 0}
  ,9: {10: 23, 13: 4, 5: 18, 6: 0}
  ,10: {11: 37, 13: 37, 14: 0, 6: 11, 7: 0, 9: 0}
  ,11: {14: 14, 15: 0, 5: 14, 7: 0, 8: 0, 10: 0}
  ,12: {13: 13, 15: 0, 7: 0, 8: 15}
  ,13: {14: 37, 15: 0, 9: 18, 10: 0, 12: 0}
  ,14: {15: 0, 10: 11, 11: 0, 13: 0}
  ,15: {11: 14, 12: 15, 13: 18, 14: 11}


    }

    # Convertir a matriz
    matriz_1 = diccionario_a_matriz(adj_dict_1)
    # Dibujar la cuadrícula
    dibujar_cuadricula(matriz_1)