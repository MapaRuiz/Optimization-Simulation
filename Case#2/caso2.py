# -*- coding: utf-8 -*-
"""Caso 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N1D3s0gN5ue8kDiR9geHIa6ksbgqTC9J
"""

import pandas as pd
import numpy as np
from collections import deque, defaultdict
import heapq

# 1. Read Excel files
capacity_matrix = pd.read_excel("T22430C2.xlsx", header=None, skiprows=1).values  # 50x50 capacity matrix
delay_matrix    = pd.read_excel("T22430R2.xlsx", header=None, skiprows=1).values     # 50x50 delay matrix
node_costs_arr  = pd.read_excel("T22430Cost.xlsx", header=None).values.flatten()      # 50 node costs

# Print the read data for verification
#print("Capacity Matrix (T22430C2):")
#print(pd.DataFrame(capacity_matrix).to_string())
#print("\nDelay Matrix (T22430R2):")
#print(pd.DataFrame(delay_matrix).to_string())
#print("\nNode Costs Array (T22430Cost):")
#print(pd.DataFrame(node_costs_arr).to_string())

# 2. Build the graph (dictionary) for nodes 1..50
n_nodes = 50
graph = {i: [] for i in range(1, n_nodes+1)}
for i in range(n_nodes):
    for j in range(n_nodes):
        c = capacity_matrix[i, j]  # capacity
        d = delay_matrix[i, j]     # delay
        # Skip if capacity=0 (no connection) or delay=999 (treated as no connection)
        if c > 0 and d < 999:
            u = i + 1
            v = j + 1
            # Store each edge as (destination, delay, capacity)
            graph[u].append((v, d, c))
# 'node_costs_arr' is a 50-element array (node_costs_arr[0] corresponds to node 1, etc.)

# ----------------------------------------------------------------
# Helper function to extract a path from flow values
# ----------------------------------------------------------------
def extract_path_from_flow(flow, source, destination):
    """
    Given a dictionary of flow values (edges with positive flow), extract one path
    from 'source' to 'destination' using DFS.
    """
    adj = defaultdict(list)
    for (u, v), f in flow.items():
        if f > 0:
            adj[u].append(v)
    path = []
    def dfs(u):
        path.append(u)
        if u == destination:
            return True
        for v in adj[u]:
            if v not in path:
                if dfs(v):
                    return True
        path.pop()
        return False
    if dfs(source):
        return path
    return []

# ----------------------------------------------------------------
# 3. Implement the Required Algorithms
# ----------------------------------------------------------------

# ====== Ford–Fulkerson with special DFS (neighbors sorted by ascending residual capacity) ======
def ford_fulkerson_max_flow_special(graph_ff, source, sink):
    residual = defaultdict(float)
    for u in graph_ff:
        for (v, d, cap) in graph_ff[u]:
            residual[(u, v)] += cap
            if (v, u) not in residual:
                residual[(v, u)] = 0.0

    def find_path_dfs(u, sink, visited, parent, flow_in):
        if u == sink:
            return flow_in
        visited.add(u)
        neighbors = []
        # Iterate over possible nodes (1 to sink inclusive)
        for v in range(1, n_nodes+2):  # n_nodes+1 is the sink
            if residual[(u, v)] > 0:
                neighbors.append((v, residual[(u, v)]))
        neighbors.sort(key=lambda x: x[1])
        for (v, cap_uv) in neighbors:
            if v not in visited and cap_uv > 0:
                parent[v] = u
                flow_next = min(flow_in, cap_uv)
                bottleneck = find_path_dfs(v, sink, visited, parent, flow_next)
                if bottleneck > 0:
                    return bottleneck
        return 0

    max_flow = 0.0
    while True:
        visited = set()
        parent = {}
        flow_found = find_path_dfs(source, sink, visited, parent, float('inf'))
        if flow_found == 0:
            break
        max_flow += flow_found
        v = sink
        while v != source:
            u = parent[v]
            residual[(u, v)] -= flow_found
            residual[(v, u)] += flow_found
            v = u
    return max_flow, residual

# ====== Cycle Canceling for Minimum–Cost (Delay) Flow ======
def cycle_canceling_min_cost_flow(graph_cc, source, sinks, required_flow):
    # Create a modified graph with an added super-sink (node n_nodes+1)
    super_sink = n_nodes + 1
    mod_graph = {u: list(edges) for u, edges in graph_cc.items()}
    mod_graph[super_sink] = []
    for dest in sinks:
        mod_graph.setdefault(dest, []).append((super_sink, 0, float('inf')))
    flow = defaultdict(float)
    for u in mod_graph:
        for (v, d, cap) in mod_graph[u]:
            flow[(u, v)] = 0.0

    def build_residual():
        residual = {}
        for u in mod_graph:
            for (v, d, cap) in mod_graph[u]:
                forward_cap = cap - flow[(u, v)]
                residual[(u, v)] = (forward_cap, d)
                if (v, u) not in residual:
                    residual[(v, u)] = (flow[(u, v)], -d)
        return residual

    def bfs_augment(residual):
        parent = {}
        queue = deque([source])
        min_cap = {source: float('inf')}
        found_path = False
        while queue and not found_path:
            u = queue.popleft()
            for v in range(1, super_sink+1):
                if (u, v) in residual:
                    cap, cost = residual[(u, v)]
                    if cap > 0 and v not in parent:
                        parent[v] = u
                        min_cap[v] = min(min_cap[u], cap)
                        if v == super_sink:
                            found_path = True
                            break
                        queue.append(v)
        if not found_path:
            return 0
        bottleneck = min_cap[super_sink]
        # Adjust bottleneck if it exceeds the remaining required flow
        current_flow = sum(flow[(source, x)] for x in range(1, super_sink+1) if (source, x) in flow)
        needed = required_flow - current_flow
        if bottleneck > needed:
            bottleneck = needed
        v = super_sink
        while v != source:
            u = parent[v]
            flow[(u, v)] += bottleneck
            v = u
        return bottleneck

    while True:
        r = build_residual()
        bneck = bfs_augment(r)
        if bneck == 0:
            break
        current_flow = sum(flow[(source, x)] for x in range(1, super_sink+1) if (source, x) in flow)
        if current_flow >= required_flow:
            break

    def find_negative_cycle(residual):
        dist = {v: 0 for v in range(1, super_sink+1)}
        pred = {v: None for v in range(1, super_sink+1)}
        for _ in range(super_sink - 1):
            for (u, v), (cap, cost) in residual.items():
                if cap > 0 and dist[v] > dist[u] + cost:
                    dist[v] = dist[u] + cost
                    pred[v] = u
        for (u, v), (cap, cost) in residual.items():
            if cap > 0 and dist[v] > dist[u] + cost:
                # Trace the negative cycle
                cycle = []
                visited = set()
                cur = v
                while cur not in visited:
                    visited.add(cur)
                    cur = pred[cur]
                    if cur is None:
                        break
                if cur is None:
                    return None
                cycle_start = cur
                cycle.append(cur)
                cur = pred[cur]
                while cur != cycle_start:
                    cycle.append(cur)
                    cur = pred[cur]
                cycle.reverse()
                return cycle
        return None

    while True:
        residual = build_residual()
        cycle = find_negative_cycle(residual)
        if cycle is None:
            break
        bottle = float('inf')
        edges = []
        for i in range(len(cycle)):
            u = cycle[i]
            v = cycle[(i+1) % len(cycle)]
            cap, cost = residual[(u, v)]
            if cap < bottle:
                bottle = cap
            edges.append((u, v))
        if bottle == 0:
            break
        for (u, v) in edges:
            if (u, v) in flow:
                flow[(u, v)] += bottle
            else:
                flow[(v, u)] -= bottle

    total_delay = 0
    for (u, v), f in flow.items():
        if f > 0:
            for (w, d, cap) in mod_graph.get(u, []):
                if w == v:
                    total_delay += d * f
                    break
    return flow, total_delay

# ====== Dijkstra’s Algorithm (Generic) ======
def dijkstra(graph_dij, source, target, weight_func):
    dist = {u: float('inf') for u in graph_dij}
    dist[source] = 0.0
    prev = {u: None for u in graph_dij}
    pq = [(0.0, source)]
    visited = set()
    while pq:
        d_u, u = heapq.heappop(pq)
        if u in visited:
            continue
        visited.add(u)
        if u == target:
            break
        for (v, delay, cap) in graph_dij.get(u, []):
            w = weight_func(u, v, delay)
            if dist[v] > d_u + w:
                dist[v] = d_u + w
                prev[v] = u
                heapq.heappush(pq, (dist[v], v))
    path = []
    if dist[target] < float('inf'):
        cur = target
        while cur is not None:
            path.append(cur)
            cur = prev[cur]
        path.reverse()
    return dist[target], path

# ----------------------------------------------------------------
# 4. Solve Each Question
# ----------------------------------------------------------------

def solve_q1():
    """
    Q1: Send 90 kb/s from node 1 (source) to nodes 49 and 50 (destinations) with minimum delay.
         We use cycle canceling on a modified graph with a super-sink connected from both nodes.
         Then we extract the paths (sequences of nodes) from the flow.
    """
    print("=== Q1: Minimum Delay Flow for 90 kb/s (Multi-Destination) ===")
    required_flow = 90.0
    # Obtain a representative flow (which we use to extract the paths)
    flow, _ = cycle_canceling_min_cost_flow(graph, 1, [49, 50], required_flow)

    # Extract a representative path for each destination
    path_49 = extract_path_from_flow(flow, 1, 49)
    path_50 = extract_path_from_flow(flow, 1, 50)

    # Extract the delivered flow per destination from the flow dictionary:
    delivered_49 = flow.get((49, n_nodes+1), 0)
    delivered_50 = flow.get((50, n_nodes+1), 0)
    total_flow = delivered_49 + delivered_50
    # Helper function to compute delay along a given path
    def path_delay(path):
        total = 0
        for i in range(len(path)-1):
            u = path[i]
            v = path[i+1]
            # Look up the edge (u, v) in the graph and sum its delay
            for (w, d, cap) in graph[u]:
                if w == v:
                    total += d
                    break
        return total

    delay_49 = path_delay(path_49)
    delay_50 = path_delay(path_50)
    total_delay_paths = delay_49 + delay_50

    print(f"Path from 1 to 49: {path_49} with delay = {delay_49} ms")
    print(f"Flow delivered to node 49: {delivered_49} kb/s")
    print(f"Path from 1 to 50: {path_50} with delay = {delay_50} ms")
    print(f"Flow delivered to node 50: {delivered_50} kb/s")
    print(f"Total flow delivered = {total_flow} kb\s")
    print(f"Combined delay of both paths = {total_delay_paths} ms\n")

def solve_q2():
    """
    Q2: Compute the maximum flow that the network supports from node 1 to both nodes 49 and 50.
         We build a modified graph with a super-sink receiving flow from both destinations.
    """
    print("=== Q2: Maximum Flow with Representative Path Delays ===")
    super_sink = n_nodes + 1
    large_capacity = 10**6  # use a large finite capacity for super-sink connections
    mod_graph = {u: list(edges) for u, edges in graph.items()}
    mod_graph[super_sink] = []
    # Connect both destination nodes to the super-sink with a large finite capacity and zero delay.
    for dest in [49, 50]:
        mod_graph.setdefault(dest, []).append((super_sink, 0, large_capacity))

    max_flow, residual = ford_fulkerson_max_flow_special(mod_graph, 1, super_sink)

    # Reconstruct the flow dictionary: for each edge, flow = original capacity - residual capacity.
    flow_dict = {}
    for u in mod_graph:
        for (v, d, cap) in mod_graph[u]:
            # Skip super-sink connections when reconstructing the representative flow.
            if v == super_sink:
                continue
            used = cap - residual.get((u, v), 0)
            if used > 0:
                flow_dict[(u, v)] = used

    # Extract representative paths for node 49 and node 50 from the computed flow.
    path_49 = extract_path_from_flow(flow_dict, 1, 49)
    path_50 = extract_path_from_flow(flow_dict, 1, 50)

    # Delivered flow on super-sink connections for each destination:
    delivered_49 = large_capacity - residual.get((49, super_sink), large_capacity)
    delivered_50 = large_capacity - residual.get((50, super_sink), large_capacity)
    total_flow = delivered_49 + delivered_50

    # Helper function to compute delay along a given path using the original graph.
    def path_delay(path):
        total = 0
        for i in range(len(path)-1):
            u = path[i]
            v = path[i+1]
            # Look up the edge (u, v) in the original graph and sum its delay.
            for (w, d, cap) in graph[u]:
                if w == v:
                    total += d
                    break
        return total

    delay_49 = path_delay(path_49)
    delay_50 = path_delay(path_50)
    total_delay_paths = delay_49 + delay_50

    print(f"Maximum flow delivered to the super-sink = {max_flow} kb/s")
    print(f"Path from 1 to 49: {path_49} with delay = {delay_49} ms")
    print(f"Flow delivered to node 49: {delivered_49} kb/s")
    print(f"Path from 1 to 50: {path_50} with delay = {delay_50} ms")
    print(f"Flow delivered to node 50: {delivered_50} kb/s")
    print(f"Total flow delivered = {total_flow} kb/s")
    print(f"Combined delay of both paths = {total_delay_paths} ms\n")

def solve_q3():
    """
    Q3: Single route (min-delay) from node 1 to node 49 using Dijkstra’s algorithm.
    """
    print("=== Q3: Min-Delay Path from 1 to 49 ===")
    weight_func = lambda u, v, delay: delay
    dist, path = dijkstra(graph, 1, 49, weight_func)
    print(f"Min-delay path from 1 to 49: {path}")
    print(f"Total delay = {dist}\n")

def solve_q4():
    """
    Q4: Single route (min-delay) from node 1 to node 50 using Dijkstra’s algorithm.
    """
    print("=== Q4: Min-Delay Path from 1 to 50 ===")
    weight_func = lambda u, v, delay: delay
    dist, path = dijkstra(graph, 1, 50, weight_func)
    print(f"Min-delay path from 1 to 50: {path}")
    print(f"Total delay = {dist}\n")

def solve_q5():
    """
    Q5: Single route from 1 to 49 that minimizes node cost.
         Here the cost of an edge is defined as the fixed cost of using the destination node.
    """
    print("=== Q5: Min-Cost (Node Cost) Path from 1 to 49 ===")
    def cost_func(u, v, delay):
        return node_costs_arr[v-1]
    dist, path = dijkstra(graph, 1, 49, cost_func)
    total_delay = 0
    for i in range(len(path)-1):
        u = path[i]
        v = path[i+1]
        for (vv, d, cap) in graph[u]:
            if vv == v:
                total_delay += d
                break
    print(f"Min-cost path from 1 to 49: {path}")
    print(f"Total node cost = {dist}")
    print(f"Total delay = {total_delay}\n")

def solve_q6():
    """
    Q6: Single route from 1 to 50 that minimizes node cost.
    """
    print("=== Q6: Min-Cost (Node Cost) Path from 1 to 50 ===")
    def cost_func(u, v, delay):
        return node_costs_arr[v-1]
    dist, path = dijkstra(graph, 1, 50, cost_func)
    total_delay = 0
    for i in range(len(path)-1):
        u = path[i]
        v = path[i+1]
        for (vv, d, cap) in graph[u]:
            if vv == v:
                total_delay += d
                break
    print(f"Min-cost path from 1 to 50: {path}")
    print(f"Total node cost = {dist}")
    print(f"Total delay = {total_delay}\n")

def solve_q7():
    """
    Q7: Recompute Q3 and Q4 but only consider edges with delay > 40.
    """
    print("=== Q7: Min-Delay Paths with Edge Delay > 40 ===")
    filtered = {}
    for u in graph:
        filtered[u] = []
        for (v, d, cap) in graph[u]:
            if d > 40:
                filtered[u].append((v, d, cap))

    # Use Dijkstra’s algorithm on the filtered graph
    wfunc = lambda u, v, dd: dd
    dist49, path49 = dijkstra(filtered, 1, 49, wfunc)
    dist50, path50 = dijkstra(filtered, 1, 50, wfunc)

    # Helper function to compute delay along a given path and get per-edge breakdown
    def path_delay_breakdown(path):
        breakdown = []
        total = 0
        for i in range(len(path)-1):
            u = path[i]
            v = path[i+1]
            # Look up the edge (u, v) in the original graph and retrieve its delay.
            for (w, d, cap) in graph[u]:
                if w == v:
                    breakdown.append((u, v, d))
                    total += d
                    break
        return total, breakdown

    total49, breakdown49 = path_delay_breakdown(path49)
    total50, breakdown50 = path_delay_breakdown(path50)

    print(f"Min-delay path (delay > 40) from 1 to 49: {path49}, total delay = {total49} ms")
    for (u, v, d) in breakdown49:
        print(f"  Edge {u} -> {v}: delay = {d} ms")

    print(f"\nMin-delay path (delay > 40) from 1 to 50: {path50}, total delay = {total50} ms")
    for (u, v, d) in breakdown50:
        print(f"  Edge {u} -> {v}: delay = {d} ms")
    print("")

def solve_q8(alpha=1.0, beta=1.0):
    """
    Q8: Find a route that balances both node cost and delay using a weighted sum objective.
         The objective function is defined as:  objective = alpha*(node cost) + beta*(delay)
    """
    print("=== Q8: Weighted-Sum (Min Cost and Min Delay) Route ===")
    def wfunc(u, v, d):
        return alpha * node_costs_arr[v-1] + beta * d
    best_dest = None
    best_obj = float('inf')
    best_path = None
    best_node_cost = None
    best_delay = None
    for dest in [49, 50]:
        obj, path = dijkstra(graph, 1, dest, wfunc)
        total_node_cost = 0
        total_delay = 0
        for i in range(len(path)-1):
            u = path[i]
            v = path[i+1]
            total_node_cost += node_costs_arr[v-1]
            for (vv, dd, cap) in graph[u]:
                if vv == v:
                    total_delay += dd
                    break
        print(f"Weighted-sum route from 1 to {dest}: {path}")
        print(f"  Sum of node costs = {total_node_cost}")
        print(f"  Sum of delays = {total_delay}")
        print(f"  Objective value = {obj}\n")
        if obj < best_obj:
            best_obj = obj
            best_path = path
            best_dest = dest
            best_node_cost = total_node_cost
            best_delay = total_delay
    print("Best overall route based on weighted sum:")
    print(f"Destination: {best_dest}")
    print(f"Route: {best_path}")
    print(f"Sum of node costs: {best_node_cost}")
    print(f"Sum of delays: {best_delay}")
    print(f"Objective value: {best_obj}\n")

# ----------------------------------------------------------------
# Main: Solve All Questions
# ----------------------------------------------------------------

def main():
    solve_q1()
    solve_q2()
    solve_q3()
    solve_q4()
    solve_q5()
    solve_q6()
    solve_q7()
    solve_q8(alpha=1.0, beta=1.0)

if __name__ == "__main__":
    main()